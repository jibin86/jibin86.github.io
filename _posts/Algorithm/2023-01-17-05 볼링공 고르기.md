---
layout: single
title:  "[그리디] 05 볼링공 고르기"
# excerpt: "16~20년 코딩 테스트 기출문제 유형 분석"
categories: Algorithm
tags: [Algorithm, 그리디]
toc: true # 포스트의 헤더들만 보여주는 목차 
toc_sticky: true  # 목차가 스크롤을 따라 움직이게 된다
# date: 2022-12-27
# last_modified_at : 이 글을 수정한 날짜
---

# 05 볼링공 고르기

## **그리디란?**

- 현재 상황에서 가장 좋아 보이는 것만을 선택하는 알고리즘이다.
- 정확한 답을 도출하지 못할 수도 있지만 코딩테스트에서는 대부분 ‘최적의 해’를 찾는 문제가 출제되므로 그리디 알고리즘의 정당성을 고민하면서 문제 해결 방안을 떠올려야한다.
- 다양한 그리디 알고리즘
    - 다익스트라 최단 경로 알고리즘
        - 암기가 필요한 알고리즘이다. 팀 노트 필요!
        - 특정 노드까지의 최단 거리 계산한 다음 메모리에 저장하고 나중에 필요할 때 다시 꺼내 본다는 점에서 다이나믹 프로그래밍으로 분류하기도 한다.
    - 크루스칼 알고리즘
        - 우선순위 큐 (최소 힙, 최대 힙)
        - 여러 개의 값들 중 **최댓값이나 최솟값을 빠르게 찾아내도록** 만들어진 자료구조이다.

---

## 문제

A,B 두 사람이 볼링을 치고 있습니다. 두 사람은 서로 무게가 다른 볼링공을 고르려고 합니다. 볼링공은 총 N개가 있으며 각 볼링공마다 무게가 적혀 있고, 공의 번호는 1번부터 순서대로 부여됩니다. 또한 같은 무게의 공이 여러 개 있을 수 있지만, 서로 다른 공으로 간주합니다. 볼링공의 무게는 1부터 M까지의 자연수 형태로 존재합니다.

예를 들어 N이 5이고, M이 3이며 각각의 무게가 차례대로 1,3,2,3,2일 때 각 공의 번호가 차례대로 1번부터 5번까지 부여됩니다. 이때 두 사람이 고를 수 있는 볼링공 번호의 조합을 구하면 다음과 같습니다.

> (1번, 2번), (1번, 3번), (1번, 4번), (1번, 5번), (2번, 3번), (2번, 5번), (3번, 4번), (4번, 5번)
> 

결과적으로 두 사람이 공을 고르는 경우의 수는 8가지입니다. N개의 공의 무게가 각각 주어질 때, 두 사람이 볼링공을 고르는 경우의 수를 구하는 프로그램을 작성하세요.

### 입력 조건

- 첫째 줄에 볼링공의 개수 N, 공의 최대 무게 M이 공백으로 구분되어 각각 자연수 형태로 주어집니다. (1<=N<=1,000 ,1<=M<=10)
- 둘째 줄에 각 볼링공의 무게 K가 공백으로 구분되어 순서대로 자연수 형태로 주어집니다. (1<=K<=M)

### 출력 조건

- 첫째 줄에 두 사람이 볼링공을 고르는 경우의 수를 출력합니다.

### **입력 예시**

```python
5 3 
1 3 2 3 2
```

### **출력 예시**

```python
8
```

---

## 사고 과정

- 서로 다른 공 2개를 선택하므로 이는 nCr 조합이다.
- 두 사람이 동일한 무게를 가지고 있는 경우를 제거한다 ⇒ if문

---

## 풀이

```python
import itertools

n, m = map(int, input().split())
balls = list(map(int, input().split()))

same_cnt = 0
# 조합
nCr = list(itertools.combinations(balls, 2))
for p in nCr:
  if p[0] == p[1]:
    same_cnt += 1

print(len(nCr) - same_cnt)
```

---

## 💡**사고 과정 흐름**을 **공식화**하자

- itertools 사용하기
    
    import itertools
    
    - 순열 4P2
        
        itertools.permutations([1, 2, 3, 4], 2)
        
    - 조합 4C2
        
        itertools.combinations([1, 2, 3, 4], 2)
        
    - 중복순열 4π2
        
        itertools.product([1, 2, 3, 4],2)
        
    - 중복 조합 4H2
        
        itertools.combinations_with_replacement([1, 2, 3, 4],2)